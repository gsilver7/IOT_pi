{"version":3,"file":"receive.js","sourceRoot":"","sources":["../../../../src/record/receive.ts"],"names":[],"mappings":"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","sourcesContent":["import type { CipherContext } from \"../context/cipher\";\nimport type { DtlsContext } from \"../context/dtls\";\nimport { Alert } from \"../handshake/message/alert\";\nimport { debug } from \"../imports/common\";\nimport { AlertDesc, ContentType } from \"./const\";\nimport { FragmentedHandshake } from \"./message/fragment\";\nimport { DtlsPlaintext } from \"./message/plaintext\";\n\nconst log = debug(\"werift-dtls : packages/dtls/record/receive.ts : log\");\nconst err = debug(\"werift-dtls : packages/dtls/record/receive.ts : err\");\n\nexport const parsePacket = (data: Buffer) => {\n  let start = 0;\n  const packets: DtlsPlaintext[] = [];\n  while (data.length > start) {\n    const fragmentLength = data.readUInt16BE(start + 11);\n    if (data.length < start + (12 + fragmentLength)) {\n      break;\n    }\n    const packet = DtlsPlaintext.deSerialize(data.subarray(start));\n    packets.push(packet);\n\n    start += 13 + fragmentLength;\n  }\n\n  return packets;\n};\n\nexport const parsePlainText =\n  (dtls: DtlsContext, cipher: CipherContext) =>\n  (\n    plain: DtlsPlaintext,\n  ): {\n    type: ContentType;\n    data: any;\n  }[] => {\n    const contentType = plain.recordLayerHeader.contentType;\n\n    switch (contentType) {\n      case ContentType.changeCipherSpec: {\n        log(dtls.sessionId, \"change cipher spec\");\n        return [\n          {\n            type: ContentType.changeCipherSpec,\n            data: undefined,\n          },\n        ];\n      }\n      case ContentType.handshake: {\n        let raw = plain.fragment;\n        try {\n          if (plain.recordLayerHeader.epoch > 0) {\n            log(dtls.sessionId, \"decrypt handshake\");\n            raw = cipher.decryptPacket(plain);\n          }\n        } catch (error) {\n          err(dtls.sessionId, \"decrypt failed\", error);\n          throw error;\n        }\n        try {\n          let start = 0;\n          const handshakes: { type: ContentType; data: any }[] = [];\n          while (raw.length > start) {\n            const handshake = FragmentedHandshake.deSerialize(\n              raw.subarray(start),\n            );\n            handshakes.push({ type: ContentType.handshake, data: handshake });\n            start += handshake.fragment_length + 12;\n          }\n\n          return handshakes;\n        } catch (error) {\n          err(dtls.sessionId, \"decSerialize failed\", error, raw);\n          throw error;\n        }\n      }\n      case ContentType.applicationData: {\n        return [\n          {\n            type: ContentType.applicationData,\n            data: cipher.decryptPacket(plain),\n          },\n        ];\n      }\n      case ContentType.alert: {\n        let alert = Alert.deSerialize(plain.fragment);\n\n        // TODO impl more better about handle encrypted alert\n        if (AlertDesc[alert.description] == undefined) {\n          const dec = cipher.decryptPacket(plain);\n          alert = Alert.deSerialize(dec);\n        }\n        err(\n          dtls.sessionId,\n          \"ContentType.alert\",\n          alert,\n          AlertDesc[alert.description],\n          \"flight\",\n          dtls.flight,\n          \"lastFlight\",\n          dtls.lastFlight,\n        );\n        if (alert.level > 1) {\n          throw new Error(\"alert fatal error\");\n        }\n        return [{ type: ContentType.alert, data: undefined }];\n      }\n      default: {\n        return [{ type: ContentType.alert, data: undefined }];\n      }\n    }\n  };\n"]}