import { type Address, Event } from "./imports/common";
import { Candidate } from "./candidate";
import { MdnsLookup } from "./dns/lookup";
import { CandidatePair, type IceConnection, type IceOptions, type IceState } from "./iceBase";
import { Message } from "./stun/message";
import type { Protocol } from "./types/model";
export declare class Connection implements IceConnection {
    private _iceControlling;
    localUsername: string;
    localPassword: string;
    remoteIsLite: boolean;
    remotePassword: string;
    remoteUsername: string;
    checkList: CandidatePair[];
    localCandidates: Candidate[];
    stunServer?: Address;
    turnServer?: Address;
    options: IceOptions;
    remoteCandidatesEnd: boolean;
    localCandidatesEnd: boolean;
    generation: number;
    userHistory: {
        [username: string]: string;
    };
    private readonly tieBreaker;
    state: IceState;
    lookup?: MdnsLookup;
    private _remoteCandidates;
    nominated?: CandidatePair;
    private nominating;
    private checkListDone;
    private checkListState;
    private earlyChecks;
    private earlyChecksDone;
    private localCandidatesStart;
    private protocols;
    private queryConsentHandle?;
    private promiseGatherCandidates?;
    readonly onData: Event<[Buffer]>;
    readonly stateChanged: Event<[IceState]>;
    readonly onIceCandidate: Event<[Candidate]>;
    constructor(_iceControlling: boolean, options?: Partial<IceOptions>);
    get iceControlling(): boolean;
    set iceControlling(value: boolean);
    restart(): Promise<void>;
    resetNominatedPair(): void;
    setRemoteParams({ iceLite, usernameFragment, password, }: {
        iceLite: boolean;
        usernameFragment: string;
        password: string;
    }): void;
    gatherCandidates(): Promise<void>;
    private ensureProtocol;
    private getCandidates;
    connect(): Promise<void>;
    private unfreezeInitial;
    private schedulingChecks;
    private queryConsent;
    close(): Promise<void>;
    private setState;
    addRemoteCandidate(remoteCandidate: Candidate | undefined): Promise<void>;
    send: (data: Buffer) => Promise<void>;
    getDefaultCandidate(): Candidate;
    set remoteCandidates(value: Candidate[]);
    get remoteCandidates(): Candidate[];
    private sortCheckList;
    private findPair;
    private switchRole;
    private checkComplete;
    checkStart: (pair: CandidatePair) => {
        awaitable: Promise<void>;
        resolve: (value: void | PromiseLike<void>) => void;
        reject: (reason?: any) => void;
    };
    private addPair;
    checkIncoming(message: Message, addr: Address, protocol: Protocol): void;
    private tryPair;
    private pairLocalProtocol;
    private pairRemoteCandidate;
    private buildRequest;
    private respondError;
}
