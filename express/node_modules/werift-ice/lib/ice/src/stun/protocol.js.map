{"version":3,"file":"protocol.js","sourceRoot":"","sources":["../../../../src/stun/protocol.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, UdpTransport, debug } from \"../imports/common\";\n\nimport type { Address, InterfaceAddresses } from \"../../../common/src/network\";\nimport type { Candidate } from \"../candidate\";\n\nimport type { Protocol } from \"../types/model\";\nimport { classes } from \"./const\";\nimport { type Message, parseMessage } from \"./message\";\nimport { Transaction } from \"./transaction\";\n\nconst log = debug(\"werift-ice : packages/ice/src/stun/protocol.ts\");\n\nexport class StunProtocol implements Protocol {\n  static readonly type = \"stun\";\n  readonly type = StunProtocol.type;\n  transport!: UdpTransport;\n  transactions: { [key: string]: Transaction } = {};\n  get transactionsKeys() {\n    return Object.keys(this.transactions);\n  }\n  localCandidate?: Candidate;\n  sentMessage?: Message;\n  localIp?: string;\n\n  readonly onRequestReceived = new Event<[Message, Address, Buffer]>();\n  readonly onDataReceived = new Event<[Buffer]>();\n\n  constructor() {}\n\n  connectionMade = async (\n    useIpv4: boolean,\n    portRange?: [number, number],\n    interfaceAddresses?: InterfaceAddresses,\n  ) => {\n    if (useIpv4) {\n      this.transport = await UdpTransport.init(\"udp4\", {\n        portRange,\n        interfaceAddresses,\n      });\n    } else {\n      this.transport = await UdpTransport.init(\"udp6\", {\n        portRange,\n        interfaceAddresses,\n      });\n    }\n\n    this.transport.onData = (data, addr) => {\n      this.datagramReceived(data, addr);\n    };\n  };\n\n  private datagramReceived(data: Buffer, addr: Address) {\n    try {\n      const message = parseMessage(data);\n      if (!message) {\n        if (this.localCandidate) {\n          this.onDataReceived.execute(data);\n        }\n        return;\n      }\n      // log(\"parseMessage\", addr, message.toJSON());\n      if (\n        (message.messageClass === classes.RESPONSE ||\n          message.messageClass === classes.ERROR) &&\n        this.transactionsKeys.includes(message.transactionIdHex)\n      ) {\n        const transaction = this.transactions[message.transactionIdHex];\n        transaction.responseReceived(message, addr);\n      } else if (message.messageClass === classes.REQUEST) {\n        this.onRequestReceived.execute(message, addr, data);\n      }\n    } catch (error) {\n      log(\"datagramReceived error\", error);\n    }\n  }\n\n  getExtraInfo(): Address {\n    const { address: host, port } = this.transport.address;\n    return [host, port];\n  }\n\n  async sendStun(message: Message, addr: Address) {\n    const data = message.bytes;\n    await this.transport.send(data, addr).catch(() => {\n      log(\"sendStun failed\", addr, message);\n    });\n  }\n\n  async sendData(data: Buffer, addr: Address) {\n    await this.transport.send(data, addr);\n  }\n\n  async request(\n    request: Message,\n    addr: Address,\n    integrityKey?: Buffer,\n    retransmissions?: number,\n  ) {\n    // \"\"\"\n    // Execute a STUN transaction and return the response.\n    // \"\"\"\n    if (this.transactionsKeys.includes(request.transactionIdHex))\n      throw new Error(\"already request ed\");\n\n    if (integrityKey) {\n      request.addMessageIntegrity(integrityKey);\n      request.addFingerprint();\n    }\n\n    const transaction: Transaction = new Transaction(\n      request,\n      addr,\n      this,\n      retransmissions,\n    );\n    this.transactions[request.transactionIdHex] = transaction;\n\n    try {\n      return await transaction.run();\n    } catch (e) {\n      throw e;\n    } finally {\n      delete this.transactions[request.transactionIdHex];\n    }\n  }\n\n  async close() {\n    Object.values(this.transactions).forEach((transaction) => {\n      transaction.cancel();\n    });\n    await this.transport.close();\n    this.onRequestReceived.complete();\n    this.onDataReceived.complete();\n  }\n}\n"]}